# Документация класса ConcreteArgumentBuilder

Этот шаблонный класс реализует паттерн проектирования "Builder": ссылки на объекты этого 
класса должна возвращать функция добавления аргумента из `ArgParser`, к нему должен 
обращаться пользователь, добавляя информацию об аргументе. Реализует функции добавления 
любой информации про аргумент и функцию построения. Наследует абстрактному классу 
`ArgumentBuilder`. Параметр шаблона - имя типа `T`. Находится в пространстве имён 
`ArgumentParser`.

## Объявление и определение

Объявлен в [ConcreteArgumentBuilder.hpp](../ConcreteArgumentBuilder.hpp). <br>
Определен там же.

## Зависимости

Зависит от [ConcreteArgument.hpp](../ConcreteArgument.hpp) и
[ArgumentBuilder.hpp](../ArgumentBuilder.hpp).

## Связанные документы

* Документация класса [ConcreteArgumentBuilder](ConcreteArgumentBuilder.md) -
  информация о задании параметров аргументов.

## Публичные поля

Класс не имеет публичных полей.

## Публичные методы

### ConcreteArgumentBuilder

Принимает короткий ключ в виде `char`, длинный ключ в виде *constant C-style string*, 
описание аргумента в виде *constant C-style string*. Не предназначен для прямого вызова
пользователем, поскольку имеет смысл только во внутренней логике класса `ArgParser`.
```cpp
ConcreteArgumentBuilder(char short_name, const char* long_name, const char* description);
```
Конструктор без параметров и конструктор копирования, а также оператор присваивания с 
копированием удалены.
```cpp
ConcreteArgumentBuilder() = delete;
ConcreteArgumentBuilder(const ConcreteArgumentBuilder& other) = delete;
ConcreteArgumentBuilder& operator=(const ConcreteArgumentBuilder& other) = delete;
```

### MultiValue

Метод, отвечающий за придание аргументу свойства принятия множества значений. Принимает
минимальное обязательно число значений (по умолчанию ноль). Возвращает ссылку на этот
аргумент.
```cpp
ConcreteArgumentBuilder& MultiValue(size_t min = 0);
```

### Positional

Метод, отвечающий за придание аргументу свойства позиционности - считывания значения 
аргумента без ключа. Возвращает ссылку на этот аргумент.
```cpp
ConcreteArgumentBuilder& Positional();
```

### StoreValue

Метод, отвечающий за придание аргументу свойства хранения значения во внешней 
переменной. Принимает ссылку на переменную, где должно храниться значение. 
Возвращает ссылку на этот аргумент.
```cpp
ConcreteArgumentBuilder& StoreValue(T& value);
```

### StoreValues

Метод, отвечающий за придание аргументу свойства хранения значений во внешнем 
`std::vector`. Принимает ссылку на `std::vector<T>`, где должны храниться значения.
Возвращает ссылку на этот аргумент.
```cpp
ConcreteArgumentBuilder& StoreValues(std::vector<T>& values);
```

### Default

Метод, отвечающий за придание аргументу значения по умолчанию. Принимает значение по 
умолчанию. Возвращает ссылку на этот аргумент.
```cpp
ConcreteArgumentBuilder& Default(T value);
```

### AddValidate

Метод, отвечающий за определение функции валидации для аргумента. Принимает
`std::function` валидации, которая должна принимать единственный аргумент: ссылку на 
`std::string`, и возвращать `bool`. Под валидацией подразумевается проверка на общую 
корректность потенциального значения. Функция валидации по умолчанию всегда принимает 
истинное значение. Возвращает ссылку на этот аргумент.
```cpp
ConcreteArgumentBuilder& AddValidate(const std::function<bool(std::string&)>& validate);
```

### AddIsGood

Метод, отвечающий за определение функции валидации для аргумента. Принимает 
`std::function` проверки, которая должна принимать единственный аргумент: ссылку на
`std::string`, и возвращать `bool`. Под проверкой подразумевается проверка на полную
корректность потенциального значения. Функция проверки по умолчанию всегда принимает
истинное значение. Возвращает ссылку на этот аргумент.
```cpp
ConcreteArgumentBuilder& AddIsGood(const std::function<bool(std::string&)>& is_good);
```

### build

Метод, отвечающий за создание аргумента по переданным параметрам. Не принимает никаких
аргументов. Возвращает указатель на интерфейс аргумента. Если значения по умолчанию 
нет, а также аргумент не является MultiValue, то считается, что он обязательный. Если 
аргумент логического типа (`Flag`), то считается, что его значение по умолчанию - 
`false`, если пользователь не указал иного. Не предназначен для прямого вызова 
пользователем, поскольку имеет смысл только во внутренней логике класса`ArgParser`.
```cpp
Argument* build() override;
```

### GetInfo

Метод, предоставляющий информацию об аргументе в виде структуры `ArgumentInformation`,
хранящая типонезависимую информацию об аргументе. Ничего не принимает. Возвращает
неизменяемую ссылку на объект `ArgumentInformation`. Не модифицирует объект. Не должен 
вызываться без использования значения.
```cpp
[[nodiscard]] const ArgumentInformation& GetInfo() const override;
```

### GetDefaultValue()

Метод, предоставляющий информацию о значении аргумента по умолчанию в виде строки. 
Ничего не принимает. Возвращает `std::string` со строковым представлением значения 
по умолчанию. Не модифицирует объект. Не должен вызываться без использования значения.
```cpp
[[nodiscard]] std::string GetDefaultValue() const override;
```

## Приложение 1. Поддерживаемые типы аргументов, логика их парсинга

### Целочисленные типы
* `Short` - `int16_t`: 16-битное знаковое число. Получается из целочисленного
  литерала, подходящего под ограничения 16-битного знакового числа и являющегося
  _подходящим_ (таким, что функция проверки принимает истинное значение).
* `Int` - `int32_t`: 32-битное знаковое число. Получается из целочисленного
  литерала, подходящего под ограничения 32-битного знакового числа и являющегося
  _подходящим_.
* `LongLong` - `int64_t`: 64-битное знаковое число. Получается из целочисленного
  литерала, подходящего под ограничения 64-битного знакового числа и являющегося
  _подходящим_.
* `UnsignedShort` - `uint16_t`: 16-битное беззнаковое число. Получается из
  целочисленного литерала, подходящего под ограничения 16-битного беззнакового числа и
  являющегося _подходящим_.
* `UnsignedInt` - `uint32_t`: 32-битное беззнаковое число. Получается из
  целочисленного литерала, подходящего под ограничения 32-битного беззнакового числа и
  являющегося _подходящим_.
* `UnsignedLongLong` - `uint64_t`: 64-битное беззнаковое число. Получается из
  целочисленного литерала, подходящего под ограничения 64-битного беззнакового числа и
  являющегося _подходящим_.

### Дробные типы
* `Float` - `float`: 32-битное число с плавающей точкой. Получается из
  дробного литерала, подходящего под ограничения 32-битного числа с плавающей точкой и
  являющегося _подходящим_.
* `Double` - `double`: 64-битное число с плавающей точкой. Получается из
  дробного литерала, подходящего под ограничения 64-битного числа с плавающей точкой и
  являющегося _подходящим_.
* `LongDouble` - `long double`: 80-битное число с плавающей точкой. Получается из
  дробного литерала, подходящего под ограничения 80-битного числа с плавающей точкой и
  являющегося _подходящим_.

### Элементарные типы
* `Flag` - `bool`: логическая переменная. Значение по умолчанию всегда `false`, при
  наличии среди аргументов командной строки флага считается `true`. Также возможно
  явное указание значения по аналогии с прочими аргументами: *false* и *0* считываются
  как `false`, *true* и *1* считываются как `true`.
* `Char` - `char`: символ. Получается из _подходящего_ символьного литерала - escape
  sequence или одного символа, также возможно задание в виде `\xXX`, при этом `0xXX` -
  код символа в шестнадцатеричной системе счисления, а также в виде `\XXX`, при этом
  `0XXX` - код символа в восьмеричной системе счисления.

### Строковые типы
* `String` - `std::string`: строка. Получается из строкового литерала без пробелов,
  являющегося _подходящим_.
* `CompositeString` - `CompositeString`: удовлетворяющая требованию строка,
  возможно, содержащая пробелы. Получается из одного или нескольких идущих подряд
  (разделённых пробелами) строковых литералов, прошедших _валидацию_ и обладающих
  следующим свойством: вся строка является _подходящей_, но если убрать из нее любое
  ненулевое количество литералов, то она перестанет быть таковой.
