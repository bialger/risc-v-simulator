| Лабораторная работа №3   | M3104                       | АОВС |
|--------------------------|-----------------------------|------|
| Кэш и кодирование команд | Бигулов Александр Артурович | 2024 |

## Инструментарий

Компилятор языка C++, стандарт C++20 (MSVC на Windows, GNU GCC и CLang на Linux).

## Что реализовано

Вариант 2, реализованы все задания: рассчитаны параметры, данный код переведен в ассемблер RISC-V, реализован расчета
количества попаданий в кэш для политик LRU и bit-pLRU, а также перевод ассемблерных файлов в машинный код. 

## Результат работы на тестовых данных: [ссылка на последний успешный action с актуальными данными](https://github.com/skkv-itmo-comp-arch/se-comp-arch24-cache-isa-bialger/actions/runs/9078022501)

# Описание:

Программа состоит из трех подсистем - `argparser`, `asm_riscv`, `cache` и главной подпрограммы, которая отвечает за 
применение средств из этих подсистем для выполнения задачи.

## Подсистема argparser

Данный модуль содержит набор связанных классов, предоставляющих функционал обработки пользовательского ввода - 
аргументов командной строки, которые определяют поведение программы. 
Основной его класс - [ArgParser](./libraries/argparser/ArgParser.hpp). 
Более подробно подсистема описана [в разделе документации подсистемы](./libraries/argparser/docs/README.md). 
Особенно подробно описана [архитектура подсистемы](./libraries/argparser/docs/dev/architecture.md) и пользовательская 
[документация основного класса](./libraries/argparser/docs/ArgParser.md). 
Содержит вложенный модуль `argparser_basic`, который содержит некоторый набор вспомогательных функций, например, 
вывода ошибок красным цветом.

## Подсистема asm_riscv

Данный модуль содержит набор классов и связей между ними, предоставляющий функционал для псевдо-эмуляции исполнения
ограниченного набора команд RISC-V (RV32I, RV32M, без Zifence, Zicsr, `*ret` и `wfi` инструкций). 
Для этого эмулируются регистры процессора, псевдо-память процессора и исполнитель команд. 
Псевдо-эмуляция это потому что, вместо исполнения хранимого в памяти байт-кода непосредственно, происходит 
последовательные вызовы функций от объектов, хранящих некие нормированные переданные аргументы, а также имя инструкции.

Из связанного с этой подсистемой: файл [rv32.asm](./rv32.asm) - перевод данной функции в ассемблер RISC-V.
Был выполнен вручную, в частности, с расчетами прыжковых инструкций и инструкций условного перехода.
Подробнее про него можно прочитать в комментариях к ассемблерному коду - они достаточно обширны.
Я узнал, как записываются и что делают большинство инструкций вышеупомянутого подмножества RISC-V.

Результат перевода этого ассемблерного файла в байт-код - в файле [rv32.bin](rv32.bin).

### ProcessMemory

Данный класс предоставляет интерфейс взаимодействия с квази-оперативной памятью. 
Он имеет поле, содержащее в себе оперативную память псевдо-эмулятора - `std::vector<uint8_t>`, каждый элемент которой - 
отдельный байт, а также два поля, объекты, эмулирующие кеш для расчета процента попаданий двух разных политик.

#### Методы ReadByte, ReadHalfWord, ReadWord

Эти методы нужны для чтения, соответственно, 1- 2- и 4-байтовых беззнаковых чисел из массива памяти по переданному
адресу в порядке LittleEndian - младшие байты правее.
Выполняются с помощью метода Read - получаемый оттуда `std::vector<uint8_t>` соответственной размерности.
Например, для числа `0x12345678` это будет `{0x78, 0x56, 0x34, 0x12}`.
Также вызывает одноименные функции обоих кешей.

#### Методы WriteByte, WriteHalfWord, WriteWord

Эти методы нужны для записи, соответственно, 1- 2- и 4-байтовых беззнаковых чисел из массива памяти по переданному
адресу в порядке LittleEndian - младшие байты правее.
Выполняются с помощью метода Write - туда передается `std::vector<uint8_t>` соответственной размерности.
Также вызывает одноименные функции обоих кешей.

#### Метод Read

Данный метод возвращает `std::vector<uint8_t>`, длина которого обусловлена одноименным параметром, а содержит он копию 
отрезка массива памяти, начиная с переданного адреса.

#### Метод Write

Данный метод принимает `std::vector<uint8_t>`, который копируется в массив памяти, начиная с переданного адреса.

#### Методы GetLRUHitRate, GetBitpLRUHitRate

Эти методы возвращают результат выполнения метода GetHitRate от кешей с соответствующими политиками.

### RISCVRegisters

Этот класс является представлением регистров 32-битного процессора, а также регистра PC - Program Counter, который 
при настоящей эмуляции хранил бы адрес текущей инструкции, но используется для перехода по массиву инструкций. 
Содержит методы для их получения и изменения в определенных пределах. 
Например, нельзя изменить регистр `x0` - это всегда 0.

#### Метод GetRegister

Данный метод принимает номер регистра, возвращает его значение, как 32-битное знаковое число.

#### Метод SetRegister

Данный метод принимает номер регистра и его новое значение, заменяет старое значение, если регистр не `x0`.

#### Метод GetPC

Данный метод возвращает значение ProgramCounter, как 32-битное беззнаковое число.

#### Метод SetPC

Данный метод настраивает переданное значение как ProgramCounter.

### RISCVAssemblerCommand

Данный класс ответственен за хранение инструкции (функтора) с аргументами. 
Получая в конструктор имя команды и ее аргументы, в конструкторе он выбирает соответствующий команде функтор.
К примеру, если имя команды - `"add"`, то функтор сложит значения второго и третьего (то есть, формально из регистра 
под номером значения) регистров, а затем положит результат в первый и вернет `0`.
Все команды возвращают коды возврата, например, `ecall` вернет `1`, а `jalr` в `0` (то есть в начало программы) - `-1`.

Аргументы от одного до трех (при необходимости третий хранится как значение) регистров или от нуля до двух значений.
Номера регистров хранятся как беззнаковое 8-битное число, а значение - как знаковое 32-битное.
Имеет метод выполнения команды, который не меняет объект, но может менять передаваемые по ссылке регистры и память.

#### Метод Execute

Данный метод получает по ссылке регистры и память, и выполняет функтор от них и хранимых аргументов.

#### Методы GetCommandName, GetReg1, GetReg2, GetValue

Методы для получения информации о команде. Возвращают всю перечисленную информацию соответствующего типа.

#### Методы SignExtended12Bits и прочие подобные

Эти методы приводят переданное число к указанному в названии виде, причем в случае sign, расширение проходит с 
сохранением знака, а в unsigned - просто заполнением старших разрядов нулями. 12-битные обрезаются до первых 12 бит, а 
20-битные - сдвигаются влево так, чтобы старший их них стал 31-м.

### RISCVAssemblerReader

Класс, который приводит переданные ему строки в Base Form (все маленькими буквами), регистры имеют исключительно 
значения `x0-x31`, нет комментариев и пустых строк и затем создает из них ассемблерные команды.

#### Метод PreProcessLine

Данный метод получает ссылку на _линию_ - std::vector<std::string>, каждая из которых ранее была разделена пробелом.
Он с помощью `std::transform` сначала приводит все элементы линии в нижний регистр.
Затем он поиском по каждому элементу убирает запятые, после этого - преобразовывает записи вида `val(reg)` в `val` и 
`reg`.

> Раздел, в котором вы описываете свою реализацию:
>
> ISA:
> - как реализован транслятор asm->binary (какие классы/функции писали и зачем)
    
> Cache:
> - результат расчёта параметров системы (формулы для расчёта, пояснения к вычислениям и какие значения по итогу
    получились). Все пункты, где было написано "вычислить самостоятельно".
> - какие классы/функции созданы для представления кеша, как реализованы политики вытеснения и конфигурация в целом, как
    он работает
    > Моделирование задачи:
> - результат работы написанной программы (то, что выводится в стандартный поток вывода / файл при разных аргументах
    командной строки)
> -
> ... прочее, что считаете полезным описать ...
>
>> Представьте, что вы пришли на защиту, и вам сказали "Рассказывай, что как реализовано".

